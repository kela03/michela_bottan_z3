#decompilando il file con IDA, troviamo questa linea:
#strcpy(v5, "1840396548924");
#ciò significa che, essendo v5 così dichiarato  char v5[24];
#in ogni posizione di questo array sarà contenuto
#il codice ascii corrispondente a ciasuno di questi numeri
#Es "1" = 49


#vogliamo che checkuser2() ritorni qualcosa diverso da 0
#il che vuol dire che v_3 deve essere pari a 0
# dato che checkUser2() ritorna v3 == 0;
from z3 import *

solver = Solver()

password = []

for i in range(0, 10):
    password.append(BitVec('b%i' % i, 32))
    # Ensure only ASCII input
    solver.add(password[i] >= 48)
    solver.add(password[i] <= 122)

I = Array('kk2',BitVecSort(32), BitVecSort(32))
kk2 = [25,18,4,4,4,2,18,20,20,6]
for i in range(0,len(kk2)):
    solver.add(I[i] == kk2[i])

v5_arr = Array('e',BitVecSort(32), BitVecSort(32))
v_5 = []
stringa = "1840396548924"
for elem in stringa:
    v_5.append(ord(elem))

for i in range(0,len(v_5)):
    solver.add(v5_arr[i] == v_5[i])

v_1 = BitVecVal(0, 32)
v_2 = BitVecVal(0, 32)
c = BitVecVal(0, 32)
v_3 = BitVecVal(0, 32)


for i in range(0,10):
    v_1 += v5_arr[i] * 53
    v_2 += (v_1 %128) + (password[i] & 0xFF)
    v_3 += (((v5_arr[v_2%13]-48) * 23 + 32) % 30) ^ I[i]

solver.add((v_3) == 0)
    #print solver

print(solver.check())
m = solver.model()

flag_vals = []

for i in range(10):
    obj = password[i]
    flag_vals.append(m[obj].as_long())

flag_cr = ""

for i in range(len(flag_vals)):
    flag_cr += chr(flag_vals[i])
print(flag_cr)
